---
title: 实时操作系统里的任务调度
abbrlink: 1245973073
date: 2019-08-16 22:54:59
tags:
---

最近接手一个实时操作系统内核，在此聊聊系统中的进程管理，包括调度，通信等。
<!--more-->

### 操作系统的使用场景
该操作系统设计的场景是实时响应外部需求，因为实时性的要求，业务场景中有 36 个物理核心，每个物理核心上运行一个操作系统。业务数据流就像通过流水线一样，依次经过每个核的处理。由于每个核之间需要交互，因此操作系统需要负责进程切换，核间通信。
由于每个操作系统上只有少量进程，为了提高任务切换速度，所有的进程资源共享。这种简化版的进程在系统中被称为任务。由于使用场景明确，系统没有提供用户接口，任务创建通过代码实现，示意流程代码如下：
```c
int main(void) {

    Task tcb;
    
    tcb.name = 'Tsk_01';
    tcb.prior = 20;
    create_task(&tcb);

    tcb.name = 'Tsk_02';
    tcb.prior = 22;
    create_task(&tcb);

    OS_Start();

    printf("======error======");
    return 0;
}
```

### 任务的调度
任务调度的两个问题是 1. 何时调度，2. 如何调度。

##### 何时启动调度
按照设计，系统中每个任务优先级不同，最多支持32个任务。系统采用抢占式优先级任务调度算法。任务从就绪队列中选择优先级最高的任务执行，当出现更高的优先级时，立即切换到高优先级任务。任务的切换有两种方式：
1. 被动调度。每隔一小段时间，操作系统会进行一次检查，从就绪队列中选区最高优先级的任务，如果该任务的优先级高于当前任务，便进行任务切换。
2. 高优先级任务主动放弃运行。高优先级任务通过调用 sleep(), pend() 等函数将自身切换到就绪态，然后显式调用调度函数 Sched() 切换到就绪队列中最高优先级的任务。

这种调度方式优点是简单高效， 但是可能出现优先级翻转的问题。优先级翻转是抢占式调度常见的问题， 考虑如下场景： 
   - 系统上有三个任务A,B,C. 优先级 A < B < C. A, C 需要使用共享资源S. 
   - 在最开始，A 正在运行，使用到了共享资源 S 并对其加锁。
   - C 任务被激活，抢占 CPU。尝试使用共享资源 S ,发现被加锁。开始等待并进入到阻塞态。
   - B 任务被激活，抢占cpu，过一段时间后主动释放cpu 。
   - A 任务恢复，使用完共享资源S，释放cpu。
   - C 任务开始执行，使用共享资源 S
可以看到，由于低优先级任务 A 占用了共享资源，高优先级任务 C 被迫在任务 B 之后执行。如果 A, C 之间存在多个任务，将导致高优先级任务的响应时间不可控，在实时系统中，这是不被允许的。系统中采取优先级天花板的方法来解决这个问题：
   -  C 任务申请共享资源 S 时，如果发现共享资源 S 被低优先级任务 A 占用。便将任务 A 提高至最高优先级，然后依次执行 A 任务，C 任务。


##### 如何切换运行状态
任务切换涉及到运行状态的保存和恢复。在系统中，需要保存恢复现场有如下几种情况：
1. 进入中断，退出中断。
2. 主动放弃任务，切换至低优先级任务。即任务切换中的情况1。
3. 进入中断，就绪队列出现高优先级任务，切换任务，返回至新任务。即任务切换中的情况2.

保存现场需要将当时任务运行状态保存至当前任务栈中，接着切换任务，重新设置栈指针，然后从新的任务栈中恢复运行状态。这一部分代码因为涉及到寄存器操作，必然是汇编代码，在 ARMv8 AARCh64 下，核心代码如下：
```armasm
//asm code
intc_handle:
    save_regs
    IRS here
    if curRedey > curRuning then
        tsk_switch
    restore_regs
    eret

// c code 
void sched(){
    disable intc
    tsk_switch_ctx
    restore intc
}

tsk_switch_ctx:
  save_regs
tsk_switch:
  switch task tcb and sp
  restore_regs
  eret

save_regs:
  save X29-X0
  save SPSR, ELR, LR 

restore_regs:
  restore X29-X0
  resotre SPSR, ELR, LR 
```
任务调度两个入口分别是intc_handle 和 sched(). 中断/任务返回时，需要使用 eret 保证切换任务和 PSTATE 的状态同时切换。

