---
title: 惊群现象
abbrlink: 244159287
date: 2020-05-29 11:19:13
tags:
---

项目调试的过程中遇到了一种多线程编程的常见问题，惊群现象。
<!--more-->

## 惊群效应
惊群效应是指多进程（多线程）在同时阻塞等待同一个事件的时候，如果等待的这个事件发生，那么他就会唤醒等待的所有进程/线程，但是最终却只能有一个进程/线程获得资源，其他进程/线程获取资源失败，重新进入休眠状态，这种现象就叫做惊群效应。

考虑这样一个问题，在主进程中创建一个socket并在7100端口开始监听， fork 产生一个子进程，由于子进程的一切都是从父进程复制而来，那么子进程中是否也监听 7100 端口？
```c++
    while(1)
    {
    	client_socket = accept(server_socket,NULL,0);
        if (0 == fork())
        {
            //do something
            close(client_socket);
            return 0;
        }
        //
    }
    close(server_socket);
}
```

答案是是的。在低版本内核，当一个新的连接到来时，父进程和子进程会同时收到监听。然后其中一个会接收到连接请求。另一个继续进入休眠。在Linux2.6版本以后，内核内核已经解决了 accept() 函数的“惊群”问题。当内核接收到一个客户连接后，只会唤醒等待队列上的第一个进程或线程。所以，如果服务器采用accept阻塞调用方式，在较新的Linux系统上，已经没有“惊群”的问题了。

## epoll 惊群
对于 epoll_wait 而言，linux 内核并没有给出外媒的解决方案。在我们的项目中，我们采用了在主线程中监听 socket ,当有新的链接请求进来之后，由主线程调用 accept，建立新的连接，然后交给其他工作线程处理后续的数据读写请求，这样就可以避免了由于多线程环境下的epoll_wait惊群效应问题。

而对于多进程的程序而言，惊群需要做合适的处理。这里的处理分两种情况，epoll_create 在 fork 之前创建epoll_create 在 fork 之后创建epoll_create。

在 fork 之前创建与 accept 惊群的原因类似，当有事件发生时，等待同一个文件描述符的所有进程（线程）都将被唤醒，而且解决思路和 accept 一致。此种情况惊群效应已经被解决。

epoll_create 在 fork 之后的话，所有进程共享一个 epoll 红黑数。如果我们只需要处理 accept 事件的话，由于内核解决了 accept 惊群问题，万事大吉。但是 epoll 并不是只处理 accept 事件，accept 后续的读写事件都需要处理，还有定时或者信号事件。当连接到来时，我们需要选择一个进程来 accept，这个时候，任何一个 accept 都是可以的。当连接建立以后，后续的读写事件，却与进程有了关联。一个请求与 a 进程建立连接后，后续的读写也应该由 a 进程来做。当读写事件发生时，应该通知哪个进程呢？Epoll 并不知道，因此，事件有可能错误通知另一个进程，这是不对的。所以一般在每个进程（线程）里面会再次创建一个 epoll 事件循环机制，每个进程的读写事件只注册在自己进程的 epoll 种。我们知道 epoll 对惊群效应的修复，是建立在共享在同一个 epoll 结构上的。epoll_create 在 fork 之后执行，每个进程有单独的 epoll 红黑树，等待队列，ready 事件列表。因此，惊群效应再次出现了。有时候唤醒所有进程，有时候唤醒部分进程，可能是因为事件已经被某些进程处理掉了，因此不用在通知另外还未通知到的进程了。
对于这中情况，Nginx 给出了一个很好的解决方案。Nginx 使用了全局互斥锁，每个工作进程在 epoll_wait() 之前先去申请锁，得到锁了才继续处理，得不到锁则等待，并设置了一个负载均衡算法来权衡各个进程的任务量（当某个工作进程的任务里达到总设置量的7/8时，不再尝试去申请锁）。
